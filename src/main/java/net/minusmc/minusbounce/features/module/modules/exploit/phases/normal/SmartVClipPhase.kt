package net.minusmc.minusbounce.features.module.modules.exploit.phases.normal


import net.minusmc.minusbounce.features.module.modules.exploit.phases.PhaseMode
import net.minusmc.minusbounce.event.PacketEvent
import net.minusmc.minusbounce.event.JumpEvent
import net.minusmc.minusbounce.event.MoveEvent
import net.minusmc.minusbounce.event.BlockBBEvent
import net.minecraft.network.play.client.C03PacketPlayer
import net.minecraft.network.play.client.C0BPacketEntityAction
import net.minecraft.network.play.client.C03PacketPlayer.C04PacketPlayerPosition
import net.minecraft.util.BlockPos
import net.minecraft.init.Blocks


class SmartVClipPhase : PhaseMode("SmartVClip") {
	private var noRot: Boolean = false
	override fun onUpdate() {
		val cageCollision = (mc.theWorld.getBlockState(BlockPos(mc.thePlayer).up(3)).block != Blocks.air 
                                        && mc.theWorld.getBlockState(BlockPos(mc.thePlayer).down()).block != Blocks.air)
        noRot = (mc.thePlayer.ticksExisted in 0..40 && cageCollision)
        if (mc.thePlayer.ticksExisted in 20..39 && cageCollision) {
            mc.netHandler.addToSendQueue(C04PacketPlayerPosition(mc.thePlayer.posX, mc.thePlayer.posY - 4, mc.thePlayer.posZ, false))
            mc.thePlayer.setPosition(mc.thePlayer.posX, mc.thePlayer.posY - 4, mc.thePlayer.posZ)
        }	
	}

	override fun onPacket(event: PacketEvent) {
		val packet = event.packet
		if (packet is C03PacketPlayer && noRot && packet.rotating) event.cancelEvent()
		if (packet is C0BPacketEntityAction && noRot) event.cancelEvent()
	}

	override fun onMove(event: MoveEvent) {
		if (noRot) event.zeroXZ()
	} 

	override fun onJump(event: JumpEvent) {
		if (noRot) event.cancelEvent()
	}
	override fun onBlockBB(event: BlockBBEvent) {}
}

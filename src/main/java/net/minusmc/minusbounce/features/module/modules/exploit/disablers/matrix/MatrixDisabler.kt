package net.minusmc.minusbounce.features.module.modules.exploit.disablers.matrix


import net.minusmc.minusbounce.features.module.modules.exploit.disablers.DisablerMode
import net.minusmc.minusbounce.MinusBounce
import net.minusmc.minusbounce.features.module.modules.movement.Speed
import net.minusmc.minusbounce.features.module.modules.movement.Fly
import net.minusmc.minusbounce.event.PacketEvent
import net.minusmc.minusbounce.event.MotionEvent
import net.minusmc.minusbounce.event.EventState
import net.minusmc.minusbounce.utils.PacketUtils
import net.minusmc.minusbounce.utils.RotationUtils
import net.minusmc.minusbounce.value.BoolValue
import net.minecraft.network.play.client.C03PacketPlayer
import net.minecraft.network.play.client.C09PacketHeldItemChange
import net.minecraft.network.play.client.C08PacketPlayerBlockPlacement
import net.minecraft.network.play.client.C03PacketPlayer.C06PacketPlayerPosLook
import net.minecraft.util.BlockPos

class MatrixDisabler : DisablerMode("Matrix") {

	private val matrixNoCheck = BoolValue("NoModuleCheck", false)
	private val matrixMoveFix = BoolValue("MoveFix", true)
	private val matrixMoveOnly = BoolValue("MoveOnly", false)
	private val matrixNoMovePacket = BoolValue("NoMovePacket", true)
	private val matrixHotbarChange = BoolValue("HotbarChange", true)

	override fun onPacket(event: PacketEvent) {
		val packet = event.packet
		if (matrixNoCheck.get() || MinusBounce.moduleManager.getModule(Speed::class.java)!!.state || MinusBounce.moduleManager.getModule(Fly::class.java)!!.state) {
			if (packet is C03PacketPlayer) {
                if (matrixNoMovePacket.get() && !packet.isMoving) {
					event.cancelEvent()
					debug("no move, cancelled")
					return
				}
				if (matrixMoveFix.get()) {
                    // almost completely disable strafe check, NoFall
					packet.onGround = true
					if (!packet.rotating) { // fix fly sometimes doesn't land properly since most mc servers all refer to C04, C05, C06 as C03s aka. PacketPlayerInFlying.
						packet.rotating = true
						packet.yaw = mc.thePlayer.rotationYaw
						packet.pitch = mc.thePlayer.rotationPitch
					}
				}
			}
		}
	}

	override fun onMotion(event: MotionEvent) {
		if (event.eventState == EventState.POST && (!matrixMoveOnly.get() || isMoving())) // check post event
			if (matrixNoCheck.get() || MinusBounce.moduleManager.getModule(Fly::class.java)!!.state || MinusBounce.moduleManager.getModule(Speed::class.java)!!.state) {
				var changed = false
				if (matrixHotbarChange.get()) for (i in 0..8) {
                    // find an empty inventory slot
        			if(mc.thePlayer.inventory.mainInventory[i] == null && i != mc.thePlayer.inventory.currentItem) {
            			PacketUtils.sendPacketNoEvent(C09PacketHeldItemChange(i))
						changed = true
						debug("found empty slot $i, switching")
            			break
        			}
				}
    			
				PacketUtils.sendPacketNoEvent(C06PacketPlayerPosLook(mc.thePlayer.posX, mc.thePlayer.posY, mc.thePlayer.posZ, RotationUtils.serverRotation!!.yaw, RotationUtils.serverRotation!!.pitch, mc.thePlayer.onGround))
				mc.netHandler.addToSendQueue(C08PacketPlayerBlockPlacement(BlockPos(-1, -1, -1), -1, null, 0f, 0f, 0f))
				debug("sent placement")
				
				if (changed) {
					PacketUtils.sendPacketNoEvent(C09PacketHeldItemChange(mc.thePlayer.inventory.currentItem))
					debug("switched back")
				}
			}
	}

}

package net.minusmc.minusbounce.features.module.modules.exploit.disablers.other

import net.minusmc.minusbounce.features.module.modules.exploit.disablers.DisablerMode
import net.minusmc.minusbounce.utils.timer.MSTimer
import net.minusmc.minusbounce.value.IntegerValue
import net.minusmc.minusbounce.value.ListValue
import net.minusmc.minusbounce.event.PacketEvent
import net.minusmc.minusbounce.event.Render2DEvent
import net.minusmc.minusbounce.utils.PacketUtils
import net.minusmc.minusbounce.utils.render.Stencil
import net.minusmc.minusbounce.utils.render.RenderUtils
import net.minusmc.minusbounce.utils.misc.RandomUtils
import net.minusmc.minusbounce.ui.font.Fonts
import net.minecraft.network.play.client.C0FPacketConfirmTransaction
import net.minecraft.network.play.client.C00PacketKeepAlive
import net.minecraft.network.play.INetHandlerPlayServer
import net.minecraft.network.Packet
import net.minecraft.client.gui.ScaledResolution


import java.awt.Color
import java.util.LinkedList

class PingSpoofDisabler : DisablerMode("PingSpoof") {
	private val minpsf: IntegerValue = object : IntegerValue("MinDelay", 0, 0, 10000, "ms") {
        override fun onChanged(oldValue: Int, newValue: Int) {
            val v = maxpsf.get()
            if (v < newValue) set(v)
        }
    }
    private val maxpsf: IntegerValue = object : IntegerValue("MaxDelay", 0, 0, 10000, "ms") {
        override fun onChanged(oldValue: Int, newValue: Int) {
            val v = minpsf.get()
            if (v > newValue) set(v)
        }
    }
	private val psfStartSendMode = ListValue("StartSendMode", arrayOf("All", "First"), "All")
	private val psfSendMode = ListValue("SendMode", arrayOf("All", "First"), "All")
	private val psfWorldDelay = IntegerValue("WorldDelay", 15000, 0, 30000, "ms")


	private val queueBus = LinkedList<Packet<INetHandlerPlayServer>>()

	private var shouldActive = false
	private var sendDelay = 0
	private var msTimer = MSTimer()

	override fun onEnable() {
		queueBus.clear()
		shouldActive = false
		msTimer.reset()
	}

	override fun onDisable() {
		for (p in queueBus) PacketUtils.sendPacketNoEvent(p)
		queueBus.clear()
	}

	override fun onWorld() {
		queueBus.clear()
		msTimer.reset()
	}

	override fun onRender2D(event: Render2DEvent) {
		if (!shouldActive) {
			val sc = ScaledResolution(mc)
			val strength = (msTimer.hasTimeLeft(psfWorldDelay.get().toLong()).toFloat() / psfWorldDelay.get().toFloat()).coerceIn(0F, 1F)

			Stencil.write(true)
			RenderUtils.drawRoundedRect(sc.scaledWidth / 2F - 50F, 35F, sc.scaledWidth / 2F + 50F, 55F, 10F, Color(0, 0, 0, 140).rgb)
			Stencil.erase(true)
			RenderUtils.drawRect(sc.scaledWidth / 2F - 50F, 35F, sc.scaledWidth / 2F - 50F + 100F * strength, 55F, Color(0, 111, 255, 70).rgb)
			Stencil.dispose()
			Fonts.font40.drawCenteredString("${(msTimer.hasTimeLeft(psfWorldDelay.get().toLong()).toFloat() / 1000F).toInt()}s left...", sc.scaledWidth / 2F, 41F, -1)
		}
	}


	override fun onPacket(event: PacketEvent) {
		val packet = event.packet
		if (packet is C0FPacketConfirmTransaction && !isInventory(packet.uid)) {
			queueBus.add(packet)
			event.cancelEvent()

			debug("c0f added, action id ${packet.uid}, target id ${packet.windowId}")
		}
		if (packet is C00PacketKeepAlive) {
			queueBus.add(packet)
			event.cancelEvent()

			debug("c00 added, key ${packet.key}")
		}
	}

	override fun onUpdate() {
		if (msTimer.hasTimePassed(psfWorldDelay.get().toLong()) && !shouldActive) {
			shouldActive = true
			sendDelay = RandomUtils.nextInt(minpsf.get(), maxpsf.get())
			if (queueBus.size > 0) flush(false)
			msTimer.reset()
			debug("activated. expected next delay: ${sendDelay}ms")
		}

		if (shouldActive) {
			if (msTimer.hasTimePassed(sendDelay.toLong()) && !queueBus.isEmpty()) {
				flush(true)
				sendDelay = RandomUtils.nextInt(minpsf.get(), maxpsf.get())
				msTimer.reset()
				debug("expected next delay: ${sendDelay}ms")
			}
		}
	}

    private fun flush(check: Boolean) {
		if ((if (check) psfSendMode.get() else psfStartSendMode.get()).equals("all", true)) 
			while (queueBus.size > 0) {
				PacketUtils.sendPacketNoEvent(queueBus.poll())
			}
		else
			PacketUtils.sendPacketNoEvent(queueBus.poll())
	}

}
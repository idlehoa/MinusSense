package net.minusmc.minusbounce.features.module.modules.exploit.phases

import net.minusmc.minusbounce.MinusBounce
import net.minusmc.minusbounce.event.*
import net.minusmc.minusbounce.utils.MinecraftInstance
import net.minusmc.minusbounce.features.module.modules.exploit.Phase
import net.minusmc.minusbounce.value.Value
import net.minusmc.minusbounce.utils.ClassUtils
import net.minusmc.minusbounce.utils.timer.TickTimer
import net.minusmc.minusbounce.utils.block.BlockUtils
import net.minecraft.block.BlockAir
import net.minecraft.util.AxisAlignedBB
import net.minecraftforge.event.entity.player.PlayerUseItemEvent.Tick

abstract class PhaseMode(val modeName: String): MinecraftInstance() {
	protected val phase: Phase
		get() = MinusBounce.moduleManager[Phase::class.java]!!

	open val values: List<Value<*>>
		get() = ClassUtils.getValues(this.javaClass, this)

	open fun isPhaseable(tickTimer: TickTimer, isInsideBlock: Boolean): Boolean = (!tickTimer.hasTimePassed(2) || !mc.thePlayer.isCollidedHorizontally || !(!isInsideBlock || mc.thePlayer.isSneaking))

	open fun onEnable() {}
	open fun onDisable() {}
    open fun onUpdate() {}
    open fun onPacket(event: PacketEvent) {}
    open fun onJump(event: JumpEvent) {}
    open fun onMove(event: MoveEvent) {}
    open fun onBlockBB(event: BlockBBEvent) {
    	val entityBoundingBox: AxisAlignedBB = mc.thePlayer.entityBoundingBox ?: return
    	val boundingBox: AxisAlignedBB = event.boundingBox ?: return
        if (BlockUtils.collideBlockIntersects(entityBoundingBox) { it !is BlockAir } && boundingBox.maxY > entityBoundingBox.minY) {
			event.boundingBox = AxisAlignedBB(boundingBox.maxX, entityBoundingBox.minY, boundingBox.maxZ, boundingBox.minX, boundingBox.minY, boundingBox.minZ)
		}
	}
	open fun onTick() {}
	open fun onWorld() {}
}

package net.minusmc.minusbounce.features.module.modules.exploit.phases.normal


import net.minusmc.minusbounce.features.module.modules.exploit.phases.PhaseMode
import net.minecraft.network.play.client.C03PacketPlayer.C04PacketPlayerPosition
import net.minusmc.minusbounce.utils.block.BlockUtils
import net.minusmc.minusbounce.utils.MovementUtils
import net.minusmc.minusbounce.utils.timer.TickTimer

import net.minecraft.block.BlockAir

import kotlin.math.sin
import kotlin.math.cos

class SkipPhase : PhaseMode("Skip") {
	private val tickTimer = TickTimer()
	override fun onUpdate() {
        val isInsideBlock = BlockUtils.collideBlockIntersects(mc.thePlayer.entityBoundingBox) { it !is BlockAir }

        if (isInsideBlock) {
			mc.thePlayer.noClip = true
            mc.thePlayer.motionY = 0.0
            mc.thePlayer.onGround = true
		}

		if(!mc.thePlayer.onGround || isPhaseable(tickTimer, isInsideBlock)) {
			tickTimer.update()
			return
		}
            
        val direction = MovementUtils.direction
        val posX = sin(direction) * 0.3
        val posZ = cos(direction) * 0.3

        for(i in 0..2) {
            mc.netHandler.addToSendQueue(C04PacketPlayerPosition(mc.thePlayer.posX, mc.thePlayer.posY + 0.06, mc.thePlayer.posZ, true))
            mc.netHandler.addToSendQueue(C04PacketPlayerPosition(mc.thePlayer.posX - posX * i, mc.thePlayer.posY, mc.thePlayer.posZ + posZ * i, true))
        }

        mc.thePlayer.entityBoundingBox = mc.thePlayer.entityBoundingBox.offset(posX, 0.0, posZ)
        mc.thePlayer.setPositionAndUpdate(mc.thePlayer.posX - posX, mc.thePlayer.posY, mc.thePlayer.posZ + posZ)
        tickTimer.reset()
	}
}

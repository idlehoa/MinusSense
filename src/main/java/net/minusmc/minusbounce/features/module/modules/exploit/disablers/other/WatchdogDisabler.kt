package net.minusmc.minusbounce.features.module.modules.exploit.disablers.other

import net.minusmc.minusbounce.features.module.modules.exploit.disablers.DisablerMode
import net.minusmc.minusbounce.MinusBounce
import net.minusmc.minusbounce.event.PacketEvent
import net.minusmc.minusbounce.event.MotionEvent
import net.minusmc.minusbounce.event.EventState
import net.minusmc.minusbounce.event.Render2DEvent
import net.minusmc.minusbounce.utils.timer.MSTimer
import net.minusmc.minusbounce.value.IntegerValue
import net.minusmc.minusbounce.value.BoolValue
import net.minusmc.minusbounce.value.ListValue
import net.minusmc.minusbounce.utils.PacketUtils
import net.minusmc.minusbounce.utils.ServerUtils
import net.minusmc.minusbounce.utils.MovementUtils
import net.minusmc.minusbounce.utils.RotationUtils
import net.minusmc.minusbounce.utils.Rotation
import net.minusmc.minusbounce.features.module.modules.movement.Speed
import net.minusmc.minusbounce.features.module.modules.movement.Fly
import net.minusmc.minusbounce.features.module.modules.movement.TargetStrafe
import net.minusmc.minusbounce.ui.font.Fonts
import net.minecraft.network.play.client.C03PacketPlayer
import net.minecraft.network.play.client.C03PacketPlayer.C04PacketPlayerPosition
import net.minecraft.network.play.client.C03PacketPlayer.C05PacketPlayerLook
import net.minecraft.network.play.client.C03PacketPlayer.C06PacketPlayerPosLook
import net.minecraft.network.play.server.S08PacketPlayerPosLook
import net.minecraft.network.play.INetHandlerPlayServer
import net.minecraft.network.Packet
import net.minecraft.client.gui.ScaledResolution
import net.minecraft.network.play.client.*
import net.minecraft.network.play.server.S02PacketChat
import net.minusmc.minusbounce.ui.client.hud.element.elements.Notification

import java.util.LinkedList
import java.awt.Color

class WatchdogDisabler : DisablerMode("Watchdog") {
	private val waitingDisplayMode = ListValue("Waiting-Display", arrayOf("Top", "Middle", "Notification", "Chat", "None"), "Top")
	private val renderServer = BoolValue("Render-ServerSide", false)
	private val autoAlert = BoolValue("BanAlert", false)
	private val rotModify = BoolValue("RotationModifier", false)
	private val tifality90 = BoolValue("Tifality", false)
	private val noMoveKeepRot = BoolValue("NoMoveKeepRot", true)
	private val noC03s = BoolValue("NoC03s", true)
	private val testFeature = BoolValue("PingSpoof", false)
	private val testDelay = IntegerValue("Delay", 400, 0, 1000, "ms")
	private val checkValid = BoolValue("InvValidate", false)

	private val queueBus = LinkedList<Packet<INetHandlerPlayServer>>()
	private val anotherQueue = LinkedList<C00PacketKeepAlive>()
	private val packetQueue = LinkedList<C0FPacketConfirmTransaction>()
	private var shouldActive = false
	private var shouldModifyRotation = false
	private var lastYaw = 0F

    private var alrSendY = false

	private val wdTimer = MSTimer()

	val canModifyRotation: Boolean
		get() = (disabler.state && shouldModifyRotation)

	val canRenderInto3D: Boolean
		get() = (disabler.state && renderServer.get() && shouldModifyRotation)

	override fun onEnable() {
		packetQueue.clear()
		anotherQueue.clear()
		queueBus.clear()
		shouldActive = false
		shouldModifyRotation = false
		wdTimer.reset()
        alrSendY = false
	}

	override fun onDisable() {
		anotherQueue.forEach { PacketUtils.sendPacketNoEvent(it) }
		packetQueue.forEach { PacketUtils.sendPacketNoEvent(it) }
		packetQueue.clear()
		anotherQueue.clear()
		queueBus.clear()
	}

	override fun onWorld() {
		packetQueue.clear()
		anotherQueue.clear()
		queueBus.clear()
		shouldActive = false
		wdTimer.reset()
        alrSendY = false
	}

	override fun onRender2D(event: Render2DEvent) {
		val sc = ScaledResolution(mc)
		if (!shouldActive) {
            if (testFeature.get() && !ServerUtils.isHypixelLobby && !mc.isSingleplayer) {
				when (waitingDisplayMode.get().lowercase()) {
					"top" -> {
						Fonts.minecraftFont.drawString("Please wait...", sc.scaledWidth / 2F - Fonts.minecraftFont.getStringWidth("Please wait...") / 2F, 61.5F, Color(0, 0, 0).rgb, false)
						Fonts.minecraftFont.drawString("Please wait...", sc.scaledWidth / 2F - Fonts.minecraftFont.getStringWidth("Please wait...") / 2F, 62.5F, Color(0, 0, 0).rgb, false)
						Fonts.minecraftFont.drawString("Please wait...", sc.scaledWidth / 2F - Fonts.minecraftFont.getStringWidth("Please wait...") / 2F - 0.5F, 62F, Color(0, 0, 0).rgb, false)
						Fonts.minecraftFont.drawString("Please wait...", sc.scaledWidth / 2F - Fonts.minecraftFont.getStringWidth("Please wait...") / 2F + 0.5F, 62F, Color(0, 0, 0).rgb, false)
						Fonts.minecraftFont.drawString("Please wait...", sc.scaledWidth / 2F - Fonts.minecraftFont.getStringWidth("Please wait...") / 2F, 62F, Color(220, 220, 60).rgb, false)
					}
					"middle" -> {
						Fonts.minecraftFont.drawString("Please wait...", sc.scaledWidth / 2F - Fonts.minecraftFont.getStringWidth("Please wait...") / 2F, sc.scaledHeight / 2F + 14.5F, Color(0, 0, 0).rgb, false)
						Fonts.minecraftFont.drawString("Please wait...", sc.scaledWidth / 2F - Fonts.minecraftFont.getStringWidth("Please wait...") / 2F, sc.scaledHeight / 2F + 15.5F, Color(0, 0, 0).rgb, false)
						Fonts.minecraftFont.drawString("Please wait...", sc.scaledWidth / 2F - Fonts.minecraftFont.getStringWidth("Please wait...") / 2F - 0.5F, sc.scaledHeight / 2F + 15F, Color(0, 0, 0).rgb, false)
						Fonts.minecraftFont.drawString("Please wait...", sc.scaledWidth / 2F - Fonts.minecraftFont.getStringWidth("Please wait...") / 2F + 0.5F, sc.scaledHeight / 2F + 15F, Color(0, 0, 0).rgb, false)
						Fonts.minecraftFont.drawString("Please wait...", sc.scaledWidth / 2F - Fonts.minecraftFont.getStringWidth("Please wait...") / 2F, sc.scaledHeight / 2F + 15F, Color(220, 220, 60).rgb, false)
					}
				}
			}
		}
	}

	override fun onPacket(event: PacketEvent) {
		val packet = event.packet
        if (mc.isSingleplayer) return

        if (autoAlert.get() && packet is S02PacketChat && packet.chatComponent.unformattedText.contains(
                "Cages opened!",
                true
            )
        )
            MinusBounce.hud.addNotification(
                Notification(
                    "Speed is bannable until this notification disappears.",
                    Notification.Type.WARNING,
                    20000L
                )
            )

        if (testFeature.get() && !ServerUtils.isHypixelLobby) {
            if (packet is C0FPacketConfirmTransaction && (!checkValid.get() || !isInventory(packet.uid))) {
                event.cancelEvent()
                packetQueue.add(packet)

                debug("c0f, ${packet.uid} ID, ${packet.windowId} wID")

                if (!shouldActive) {
                    shouldActive = true
                    debug("activated")
                    when (waitingDisplayMode.get().lowercase()) {
                        "notification" -> MinusBounce.hud.addNotification(
                            Notification(
                                "Activated Disabler.",
                                Notification.Type.SUCCESS,
                                2000L
                            )
                        )

                        "chat" -> debug("Activated Disabler.", true)
                    }
                }
            }
            if (packet is C00PacketKeepAlive) {
                event.cancelEvent()
                anotherQueue.add(packet)

                wdTimer.reset()
                debug("c00, ${packet.key}")
            }
            if (packet is C03PacketPlayer || packet is C0BPacketEntityAction || packet is C08PacketPlayerBlockPlacement || packet is C0APacketAnimation) {
                if (!shouldActive)
                    event.cancelEvent()
			}
            if (packet is S08PacketPlayerPosLook && !shouldActive) {
                if (alrSendY) {
                    //mc.netHandler.addToSendQueue(C06PacketPlayerPosLook(packet.getX(), packet.getY(), packet.getZ(), packet.getYaw(), packet.getPitch(), false))
                    event.cancelEvent()
                    debug("no s08")
                } else {
                    alrSendY = true
                    debug("first s08, ignore")
                }
            }
        }

        if (noC03s.get() && packet is C03PacketPlayer)
            if (packet !is C04PacketPlayerPosition && packet !is C05PacketPlayerLook && packet !is C06PacketPlayerPosLook)
                event.cancelEvent()
	}

	override fun onMotion(event: MotionEvent) {
        val speed = MinusBounce.moduleManager[Speed::class.java]!!
        val fly = MinusBounce.moduleManager[Fly::class.java]!!
        val targetStrafe = MinusBounce.moduleManager.getModule(TargetStrafe::class.java)!!

		if (event.eventState == EventState.PRE)
			shouldModifyRotation = false

		if (event.eventState == EventState.PRE) {
			if ((speed.state || fly.state) && rotModify.get()) {
				shouldModifyRotation = true
				if (MovementUtils.isMoving) {
					val cYaw = if (targetStrafe.canStrafe) MovementUtils.getPredictionYaw(event.x, event.z) - 90F
								else MovementUtils.getRawDirection(event.yaw)

					lastYaw = cYaw
					event.yaw = cYaw
					if (tifality90.get()) event.pitch = 90F
					RotationUtils.setTargetRot(Rotation(cYaw, if (tifality90.get()) 90F else event.pitch))
				} else if (noMoveKeepRot.get()) {
					event.yaw = lastYaw
					if (tifality90.get()) event.pitch = 90F
					RotationUtils.setTargetRot(Rotation(lastYaw, if (tifality90.get()) 90F else event.pitch))
				}
			}
            if (mc.isSingleplayer) return
			if (testFeature.get() && !ServerUtils.isHypixelLobby) {
				if (shouldActive && wdTimer.hasTimePassed(testDelay.get().toLong())) {
					while (!anotherQueue.isEmpty()) {
						PacketUtils.sendPacketNoEvent(anotherQueue.poll())
						debug("c00, ${anotherQueue.size}")
					}
					while (!packetQueue.isEmpty()) {
						PacketUtils.sendPacketNoEvent(packetQueue.poll())
						debug("c0f, ${packetQueue.size}")
					}
				}
			}
		}
	}

}


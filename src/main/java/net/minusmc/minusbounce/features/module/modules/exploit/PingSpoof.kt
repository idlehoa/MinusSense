/*
 * MinusBounce Hacked Client
 * A free open source mixin-based injection hacked client for Minecraft using Minecraft Forge.
 * https://github.com/MinusMC/MinusBounce
 */
package net.minusmc.minusbounce.features.module.modules.exploit

import net.minecraft.network.Packet
import net.minecraft.network.handshake.client.C00Handshake
import net.minecraft.network.play.client.C00PacketKeepAlive
import net.minecraft.network.play.client.C16PacketClientStatus
import net.minusmc.minusbounce.event.EventTarget
import net.minusmc.minusbounce.event.PacketEvent
import net.minusmc.minusbounce.event.UpdateEvent
import net.minusmc.minusbounce.features.module.Module
import net.minusmc.minusbounce.features.module.ModuleCategory
import net.minusmc.minusbounce.features.module.ModuleInfo
import net.minusmc.minusbounce.utils.timer.TimeUtils
import net.minusmc.minusbounce.value.BoolValue
import net.minusmc.minusbounce.value.IntegerValue

@ModuleInfo(name = "PingSpoof", spacedName = "Ping Spoof", description = "Spoofs your ping to a given value.", category = ModuleCategory.EXPLOIT)
class PingSpoof: Module() {

    private val maxDelayValue: IntegerValue = object: IntegerValue("MaxDelay", 1000, 0, 5000, "ms") {
        override fun onChanged(oldValue: Int, newValue: Int) {
            val value = minDelayValue.get()
            if (value > newValue) set(value)
        }
    }

    private val minDelayValue: IntegerValue = object: IntegerValue("MinDelay", 500, 0, 5000, "ms") {
        override fun onChanged(oldValue: Int, newValue: Int) {
            val value = maxDelayValue.get()
            if (value < newValue) set(value)
        }
    }

    private val packetsMap = hashMapOf<Packet<*>, Long>()
    private val cancelC00 = BoolValue("CancelC00", true)

    override fun onDisable() {
        packetsMap.clear()
    }

    @EventTarget
    fun onPacket(event: PacketEvent) {
        val packet = event.packet

        if ((packet is C00PacketKeepAlive || packet is C16PacketClientStatus || (cancelC00.get() && packet is C00Handshake)) && !(mc.thePlayer.isDead || mc.thePlayer.health <= 0) && !packetsMap.containsKey(packet)) {
            event.cancelEvent()

            synchronized(packetsMap) {
                packetsMap[packet] = System.currentTimeMillis() + TimeUtils.randomDelay(minDelayValue.get(), maxDelayValue.get())
            }
        }
    }

    @EventTarget
    fun onUpdate(event: UpdateEvent) {
        var filtered: List<Packet<*>>

        synchronized(packetsMap) {
            filtered = packetsMap.entries.filter {
                it.value <= System.currentTimeMillis()
            }.map { it.key }
        }

        for (packet in filtered) {
            mc.netHandler.addToSendQueue(packet)
            packetsMap.remove(packet)
        }
    }

}

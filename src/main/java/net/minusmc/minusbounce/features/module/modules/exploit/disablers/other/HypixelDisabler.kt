package net.minusmc.minusbounce.features.module.modules.exploit.disablers.other

import net.minecraft.network.Packet
import net.minecraft.network.play.INetHandlerPlayServer
import net.minecraft.network.play.client.*
import net.minecraft.network.play.server.S02PacketChat
import net.minusmc.minusbounce.MinusBounce
import net.minusmc.minusbounce.event.PacketEvent
import net.minusmc.minusbounce.features.module.modules.exploit.disablers.DisablerMode
import net.minusmc.minusbounce.ui.client.hud.element.elements.Notification
import net.minusmc.minusbounce.utils.MovementUtils
import net.minusmc.minusbounce.utils.PacketUtils
import net.minusmc.minusbounce.utils.timer.MSTimer
import net.minusmc.minusbounce.value.BoolValue
import java.util.concurrent.LinkedBlockingQueue

class HypixelDisabler : DisablerMode("Hypixel") {
    private val banWarning = BoolValue("BanWarning", true)
    private val noC03 = BoolValue("NoC03Packet", true)
    private val timerA = BoolValue("Timer1", true)
    private val timerB = BoolValue("Timer2", false)
    private var counter = 0
    private var x = 0.0
    private var y = 0.0
    private var z = 0.0

    private val packets = LinkedBlockingQueue<Packet<INetHandlerPlayServer>>()
    private val timerCancelDelay = MSTimer()
    private val timerCancelTimer = MSTimer()
    private var timerShouldCancel = true
    private var inCage = true
    
    
    private var canBlink = true

    override fun onWorld() {
        counter = 0
        inCage = true
    }

    override fun onEnable() {
        counter = 0
        inCage = true
        x = 0.0
        y = 0.0
        z = 0.0
        timerCancelDelay.reset()
        timerCancelTimer.reset()
    }

    override fun onPacket(event: PacketEvent) {
        val packet = event.packet
        canBlink = true
        
        if (banWarning.get() && packet is S02PacketChat && packet.chatComponent.unformattedText.contains("Cages opened!", true)) {
            MinusBounce.hud.addNotification(Notification("Speed is bannable until this notification disappears.", Notification.Type.ERROR))
            inCage = false
        }
        
        if (mc.thePlayer.ticksExisted > 200f)
            inCage = false


        if (timerA.get() && !inCage) {
            if (packet is C02PacketUseEntity || packet is C03PacketPlayer || packet is C07PacketPlayerDigging || packet is C08PacketPlayerBlockPlacement ||
            packet is C0APacketAnimation || packet is C0BPacketEntityAction || packet is C0FPacketConfirmTransaction || packet is C00PacketKeepAlive ) {
                if (timerShouldCancel) {
                    if (!timerCancelTimer.hasTimePassed(270)) {
                        packets.add(packet as Packet<INetHandlerPlayServer>)
                        event.cancelEvent()
                        canBlink = false
                    } else {
                        debug("Timer 1 release packets")
                        debug("Size " + packets.size.toString())
                        timerShouldCancel = false
                        while (!packets.isEmpty()) {
                            PacketUtils.sendPacketNoEvent(packets.take())
                        }
                    }
                }
            }
        }
        
        //timerB
        if (timerB.get() && !inCage) {
            if (packet is C02PacketUseEntity || packet is C03PacketPlayer || packet is C07PacketPlayerDigging || packet is C08PacketPlayerBlockPlacement ||
            packet is C0APacketAnimation || packet is C0BPacketEntityAction || packet is C0FPacketConfirmTransaction || packet is C00PacketKeepAlive) {
                if (timerShouldCancel) {
                    if (!timerCancelTimer.hasTimePassed(250)) {
                        packets.add(packet as Packet<INetHandlerPlayServer>)
                        event.cancelEvent()
                        canBlink = false
                    } else {
                        debug("Timer 2 release packets")
                        debug("Size " + packets.size.toString())
                        timerShouldCancel = false
                        while (!packets.isEmpty()) {
                            PacketUtils.sendPacketNoEvent(packets.take())
                        }
                    }
                }
            }
        }


        // noC03
        if (packet is C03PacketPlayer && !MovementUtils.isMoving && noC03.get() && !inCage) {
            event.cancelEvent()
            canBlink = false
        }
    }

    override fun onUpdate() {
        
        if (timerA.get()) {
            if (timerCancelDelay.hasTimePassed(3410)) {
                timerShouldCancel = true
                timerCancelTimer.reset()
                timerCancelDelay.reset()
            }
        }
        
        // timer2
        if (timerB.get()) {
            if (timerCancelDelay.hasTimePassed(2000)) {
                timerShouldCancel = true
                timerCancelTimer.reset()
                timerCancelDelay.reset()
            }
        }
    }
}
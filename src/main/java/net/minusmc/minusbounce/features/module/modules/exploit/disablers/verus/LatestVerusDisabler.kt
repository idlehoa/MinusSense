package net.minusmc.minusbounce.features.module.modules.exploit.disablers.verus


import net.minusmc.minusbounce.features.module.modules.exploit.disablers.DisablerMode
import net.minusmc.minusbounce.event.PacketEvent
import net.minusmc.minusbounce.utils.PacketUtils
import net.minusmc.minusbounce.MinusBounce
import net.minusmc.minusbounce.value.BoolValue
import net.minusmc.minusbounce.value.IntegerValue
import net.minusmc.minusbounce.utils.timer.MSTimer
import net.minusmc.minusbounce.features.module.modules.movement.Fly
import net.minusmc.minusbounce.ui.client.hud.element.elements.Notification
import net.minecraft.network.play.client.C03PacketPlayer
import net.minecraft.network.play.server.S08PacketPlayerPosLook
import net.minecraft.network.play.client.C03PacketPlayer.C06PacketPlayerPosLook
import net.minecraft.network.play.client.C0FPacketConfirmTransaction
import net.minecraft.network.play.client.C0BPacketEntityAction
import net.minecraft.network.play.client.C0CPacketInput
import net.minecraft.init.Items

import java.util.LinkedList
import kotlin.math.sqrt

class LatestVerusDisabler : DisablerMode("LatestVerus") {

	private val verusLobbyValue = BoolValue("LobbyCheck", true)
	private val verusFlagValue = BoolValue("Flag", true)
	private val verusSlientFlagApplyValue = BoolValue("SlientFlagApply", false)
    private val verusBufferSizeValue = IntegerValue("QueueActiveSize", 300, 0, 1000)
	private val verusFlagDelayValue = IntegerValue("FlagDelay", 40, 40, 120, " tick")
	private val verusAntiFlyCheck = BoolValue("AntiFly", true)
	private val verusFakeInput = BoolValue("FakeInput", true)
	private val verusValidPos = BoolValue("ValidPosition", true)

	private val packetQueue = LinkedList<C0FPacketConfirmTransaction>()

	private val msTimer = MSTimer()
	private var shouldActive = false

	override fun shouldRun(): Boolean = mc.thePlayer != null && mc.thePlayer.inventory != null && (!verusLobbyValue.get() || !mc.thePlayer.inventory.hasItem(Items.compass)) && mc.thePlayer.ticksExisted > 5

	override fun onEnable() {
		packetQueue.clear()
		msTimer.reset()
		shouldActive = false
	}

	override fun onDisable() {
		packetQueue.clear()
		msTimer.reset()
	}

	override fun onWorld() {
		packetQueue.clear()
		msTimer.reset()
		shouldActive = false
	}

	override fun onUpdate() {
		if (verusAntiFlyCheck.get() && !shouldActive) {
			val flyMod = MinusBounce.moduleManager[Fly::class.java]!!
			if (flyMod.state) {
				flyMod.state = false
				MinusBounce.hud.addNotification(Notification("You can't fly before successful activation.", Notification.Type.WARNING))
				debug("no fly allowed")
			}
		}
		if (mc.thePlayer.ticksExisted % 15 == 0 && shouldRun()) {
			if (verusFakeInput.get()) {
				mc.netHandler.addToSendQueue(C0CPacketInput(mc.thePlayer.moveStrafing.coerceAtMost(0.98F), mc.thePlayer.moveForward.coerceAtMost(0.98F), mc.thePlayer.movementInput.jump, mc.thePlayer.movementInput.sneak))
				debug("c0c")
			}
		}
	}

	override fun onPacket(event: PacketEvent) {
		val packet = event.packet
		if (!shouldRun()) {
            msTimer.reset()
            packetQueue.clear()
			return
        }

        if (packet is C0FPacketConfirmTransaction && !isInventory(packet.uid)) {
            packetQueue.add(packet)
            event.cancelEvent()
            if(packetQueue.size > verusBufferSizeValue.get()) {
                if(!shouldActive) {
                    shouldActive = true
                    MinusBounce.hud.addNotification(Notification("Successfully put Verus into sleep.", Notification.Type.SUCCESS))
                }
                PacketUtils.sendPacketNoEvent(packetQueue.poll())
            }
            debug("c0f, ${packetQueue.size}")
        }

		if (packet is C0BPacketEntityAction) {
			event.cancelEvent()
			debug("ignored packet action")
		}

		if (packet is C03PacketPlayer) {
            if(verusFlagValue.get() && mc.thePlayer.ticksExisted % verusFlagDelayValue.get() == 0) {
                debug("modified c03")
				packet.y -= 11.015625 // just phase into ground instead (minimum to flag)
				packet.onGround = false
                packet.isMoving = false
            }
            if (verusValidPos.get()) {
				if (packet.y % 0.015625 == 0.0) {
					packet.onGround = true
					debug("true asf")
				}
			}
        }

		if (packet is S08PacketPlayerPosLook && verusSlientFlagApplyValue.get()) {
            val x = packet.x - mc.thePlayer.posX
            val y = packet.y - mc.thePlayer.posY
            val z = packet.z - mc.thePlayer.posZ
            val diff = sqrt(x * x + y * y + z * z)
            if (diff <= 8) {
                event.cancelEvent()
                debug("flag silent accept")
                PacketUtils.sendPacketNoEvent(C06PacketPlayerPosLook(packet.x, packet.y, packet.z, packet.getYaw(), packet.getPitch(), false))
            }
        }
	}
}

package net.minusmc.minusbounce.features.module.modules.exploit.phases.normal


import net.minecraft.block.BlockAir
import net.minecraft.util.BlockPos
import net.minusmc.minusbounce.features.module.modules.exploit.phases.PhaseMode
import net.minusmc.minusbounce.utils.block.BlockUtils
import net.minusmc.minusbounce.utils.timer.TickTimer
import kotlin.math.cos
import kotlin.math.sin

class ClipPhase : PhaseMode("Clip") {
	private val tickTimer = TickTimer()
	override fun onUpdate() {
        val isInsideBlock = BlockUtils.collideBlockIntersects(mc.thePlayer.entityBoundingBox) { it !is BlockAir }

        if (isInsideBlock) {
			mc.thePlayer.noClip = true
            mc.thePlayer.motionY = 0.0
            mc.thePlayer.onGround = true
		}

		if(!mc.thePlayer.onGround || isPhaseable(tickTimer, isInsideBlock)) {
			tickTimer.update()
			return
		}
            
        val yaw = Math.toRadians(mc.thePlayer.rotationYaw.toDouble())
        val oldX = mc.thePlayer.posX
        val oldZ = mc.thePlayer.posZ

        for(i in 1..10) {
            val x = sin(yaw) * i
            val z = cos(yaw) * i

            if(BlockUtils.getBlock(BlockPos(oldX - x, mc.thePlayer.posY, oldZ + z)) is BlockAir && BlockUtils.getBlock(BlockPos(oldX + x, mc.thePlayer.posY + 1, oldZ + z)) is BlockAir) {
                mc.thePlayer.setPosition(oldX - x, mc.thePlayer.posY, oldZ + z)
                break
            }
        }
        tickTimer.reset()
	}
}
